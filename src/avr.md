# Where does the vector table come from?

TL;DR: `avr-libc/crt1/gcrt1.S`

I came across the concept of "relocations" while reviewing objects generated by my research. Relocatable sections are an ELF thing (well, the concept is in a lot of object file formats, but I care about ELF in this case). Support for specific types of relocations are found in these source files:

- `~/src/gcc-dev/binutils-2.32/include/elf/avr.h`
- `~/src/gcc-dev/binutils-2.32/bfd/elf-avr.h`

For example, the relocation `R_AVR_LDI` has number 19 (which is what is stored in the ELF field) is implemented in `elf32-avr.c` in the parts of the file where you can fine `R_AVR_LDI` (I don't know exactly how this works yet).

The actual vector table is defined in `avr-libc-1.8.1/crt1/gcrt1.S`. The section `.vectors` is created and a global label `__vectors` is defined in it. Each entry that follows uses the `vector` macro defined in this file:

```avr-asm
.macro	vector name
.if (. - __vectors < _VECTORS_SIZE)
.weak	\name
.set	\name, __bad_interrupt
XJMP	\name
.endif
.endm
```

And is used like this:

```avr-asm
	.section .vectors,"ax",@progbits
	.global	__vectors
	.func	__vectors
__vectors:
	XJMP	__init
	vector	__vector_1
	# ...
```

Which does some important stuff:

- Only define entries for vectors that are supported by the target architecture. This is done by subtracting the current address from the `__vectors` label address and making sure it less than `_VECTORS_SIZE` which is defined in the header for the part(s) that the library is being compiled for (e.g. `avr/iomxx0_1.h`). It's important to note that a library is generated for every avr-libc supported part, e.g. `<build>/avr/lib/avr6/atmega2560/libcrt.a`, which is how this vector table with variable number of entires works.
- Set the vector name (e.g. `__vector_1`) to be a `weak` symbol which means that a non-`weak` symbol declared in another object file would override the definition from this file. This allows the library to contain a default implementation of the function that can be replaced by a user function defined outside of the library
- Assign a default interrupt handler, `__bad_interrupt`, to the vector name that will handle unexpected interrupts (e.g. interrupts enabled by accident or interrupts intentionally enabled but that a handler was not implemented for by accident)
- Emit the assembly instruction `XJMP` to jump to the interrupt handler
